---
title: "Function Showcase"
author: "Margaret Turner"
date: "3/27/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# `colData` manipulation

Experiment objects are un-`tidy`. Due to the underlying expectations of how information is stored in a `tidy` dataset, most `dplyr` functions (e.g. `mutate()`, `summarize()`, `filter()`) specifically operate on either columns or rows. The following functions are meant to provide more flexible manipulation of un-`tidy` experimental data.

## `arrange_columns()`

The ultimate goal of this function is to allow columns of assays within a `MultiAssayExperiment` to be rearranged by the observations of their `colData`.

**TODO**:

- Finished function should take a MAE and perform on *selected* assays.
- `arrange_cols.SE` also uses the helper function.
- Flexible `by` argument.
  - Including `desc()` option.
- Needs support for SEs with multiple assays or data not stored in `listData`.

```{r}
# DEFINE FUNCTIONS

arrange_columns <- function(.data, by1, by2) {
  UseMethod("arrange_columns")
}

# ------------------------------------------------------------------------------
# This function takes a MAE, arranges the columns of each assay, and returns a
# MAE with the arranged assays

arrange_columns.MultiAssayExperiment <- function(.data, by1, by2) {
  var1 <- deparse(substitute(by1))
  var2 <- deparse(substitute(by2))
  z <- length(.data@ExperimentList)
  reordered_mae <- .data
  for (i in 1:z) { 
    # Each experiment within the MAE has arrange_columns called on it
    # Note that the deparsed feature names are "smuggled" into the inner function by var1, var2
    reordered_mae[[i]] <- arrange_columns_helper(.data[[i]], {{ by1 }}, {{ by2 }}, var1, var2)
  }
  return(reordered_mae)
}

# ------------------------------------------------------------------------------
# A variant of arrange_columns.SE that is called from inside the arrange_columns.MAE function
# Must handle data masking differently than arrange_columns.SE, though the two could theoretically be merged

arrange_columns_helper <- function(.data, by1, by2, var1, var2) {
  assay_name <- names(.data@assays)
  new_assay <- .data@assays@data@listData[[1]][order(.data@colData[[var1]], 
                                                     .data@colData[[var2]])]
  new_assay_list <- new_assay %>% 
    matrix(., nrow = nrow(rowData(.data)),
           ncol = nrow(.data@colData)) %>% list(.)
  names(new_assay_list) <- assay_name
  new_coldata <- .data@colData %>% as.data.frame() %>% arrange({{ by1 }}, {{ by2 }})
  reordered_experiment <- SummarizedExperiment(assays = new_assay_list,
                                               colData = new_coldata,
                                               rowData = rowData(.data))
  return(reordered_experiment)
}

# ------------------------------------------------------------------------------
# This function takes a SummarizedExperiment, arranges its columns, and returns a repackaged SummarizedExperiment

arrange_columns.SummarizedExperiment <- function(.data, by1, by2) {
  # Need text feature names for order()
  var1 <- deparse(substitute(by1))
  var2 <- deparse(substitute(by2))
  assay_name <- names(.data@assays)
  new_assay <- .data@assays@data@listData[[1]][order(.data@colData[[var1]], 
                                                     .data@colData[[var2]])]
  new_assay_list <- new_assay %>% 
    matrix(., nrow = nrow(rowData(.data)),
            ncol = nrow(.data@colData)) %>% list(.)
  names(new_assay_list) <- assay_name
  # Can use embracing to arrange colData
  new_coldata <- .data@colData %>% as.data.frame() %>% arrange({{ by1 }}, {{ by2 }})
  reordered_experiment <- SummarizedExperiment(assays = new_assay_list,
                                             colData = new_coldata,
                                             rowData = rowData(.data))
  return(reordered_experiment)
}
```


# Handling sparse data

## `trim_empty_*`

Sequencing data often produces large but sparse matrices. To save space and time, it may be worthwhile to remove empty columns and/or rows.

**TODO**:

- Only `trim_empty_rows()` has been made so far, but should be straightforward to translate to `trim_empty_columns()`.
- Currently, only selecting one experiment from an MAE is supported. Finished function should allow selection of anywhere from 1 to all.
- Needs support for SEs with multiple assays or data not stored in `listData`.

```{r}
# DEFINE FUNCTIONS

trim_empty_rows <- function(.data, experiment, counts = TRUE) {
  UseMethod("trim_empty_rows")
}

#-------------------------------------------------------------------------------
# This function takes a MAE object, removes all empty rows within a specified experiment, then returns the altered MAE

trim_empty_rows.MultiAssayExperiment <- function(.data, experiment, counts = TRUE) {
  exp_name <- deparse(substitute(experiment))
  .data[[exp_name]] <- trim_empty_rows.SummarizedExperiment(.data[[exp_name]],
                                                            counts = counts)
  return(.data)
}

#------------------------------------------------------------------------------
# This function takes a SE object, removes rows with all zeros

trim_empty_rows.SummarizedExperiment <- function(.data, counts = TRUE) {
  # Create a vector indicating which rows of the matrix and rowData are nonzero
  if (counts) {
    nonempty_indices <- apply(.data@assays@data@listData[[1]], 1, sum) > 0
  } else {
    nonempty_indices <- apply(.data@assays@data@listData[[1]], 1, nonzero)
  }
  new_rowdata <- rowData(.data)[nonempty_indices, ]
  new_assay <- .data@assays@data@listData[[1]][nonempty_indices, ]
  new_assay_list <- new_assay %>% list(.)
  names(new_assay_list) <- names(.data@assays)
  trimmed_experiment <- SummarizedExperiment(assays = new_assay_list,
                                             colData = .data@colData,
                                             rowData = new_rowdata)
  return(trimmed_experiment)
}

nonzero <- function(x) {
  any(x != 0)
}

```


# Assistants

Functions that do not necessarily fit the `TidyMultitude` "&oelig;uvre" but help with functionality.

## `scale_rowwise`

Scales and centers the rows of matrix-like objects.

```{r}
scale_rowwise <- function(x, center = TRUE, scale = TRUE) {
  # Will only center if specified
  if (center) {
    x <- sweep(x, 1, apply(x, 1, mean))
  }
  # Will only scale if specified
  if (scale) {
    scales <- apply(x, 1, sd)
    for(i in 1:nrow(x)) { x[i, ] <- x[i, ]/scales[i] }
  }
  return(x)
}
```

