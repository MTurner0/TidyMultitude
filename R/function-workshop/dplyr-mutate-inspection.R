mutate.data.frame <- function(.data,
                              ...,
                              .keep = c("all", "used", "unused", "none"),
                              .before = NULL,
                              .after = NULL) {
  # Ensures that keep was set to a value in the vector, else set to "all" by
  # default
  keep <- arg_match(.keep)
  
  #dplyr_quosures(...) makes calls into a list of quosures
  cols <- mutate_cols(.data, dplyr_quosures(...), caller_env = caller_env())
  used <- attr(cols, "used")
  
  out <- dplyr_col_modify(.data, cols)
  
  # Compact out `NULL` columns that got removed.
  # These won't exist in `out`, but we don't want them to look "new".
  # Note that `dplyr_col_modify()` makes it impossible to `NULL` a group column,
  # which we rely on below.
  cols <- compact_null(cols)
  
  cols_data <- names(.data)
  cols_group <- group_vars(.data)
  
  cols_expr <- names(cols)
  cols_expr_modified <- intersect(cols_expr, cols_data)
  cols_expr_new <- setdiff(cols_expr, cols_expr_modified)
  
  cols_used <- setdiff(cols_data, c(cols_group, cols_expr_modified, names(used)[!used]))
  cols_unused <- setdiff(cols_data, c(cols_group, cols_expr_modified, names(used)[used]))
  
  .before <- enquo(.before)
  .after <- enquo(.after)
  
  if (!quo_is_null(.before) || !quo_is_null(.after)) {
    # Only change the order of new columns
    out <- relocate(out, all_of(cols_expr_new), .before = !!.before, .after = !!.after)
  }
  
  cols_out <- names(out)
  
  if (keep == "all") {
    cols_retain <- cols_out
  } else if (keep == "used") {
    cols_retain <- setdiff(cols_out, cols_unused)
  } else if (keep == "unused") {
    cols_retain <- setdiff(cols_out, cols_used)
  } else if (keep == "none") {
    cols_retain <- setdiff(cols_out, c(cols_used, cols_unused))
  }
  
  dplyr_col_select(out, cols_retain)
}

mutate_cols <- function(.data, dots, caller_env, error_call = caller_env()) {
  
  error_call <- dplyr_error_call(error_call)
  
  mask <- DataMask$new(.data, caller_env, "mutate", error_call = error_call)
  old_current_column <- context_peek_bare("column")
  
  on.exit(context_poke("column", old_current_column), add = TRUE)
  on.exit(mask$forget(), add = TRUE)
  
  rows <- mask$get_rows()
  
  new_columns <- set_names(list(), character())
  
  withCallingHandlers({
    for (i in seq_along(dots)) {
      context_poke("column", old_current_column)
      
      # get results from all the quosures that are expanded from ..i
      # then ingest them after
      quosures <- expand_across(dots[[i]])
      quosures_results <- vector(mode = "list", length = length(quosures))
      
      for (k in seq_along(quosures)) {
        quo <- quosures[[k]]
        quo_data <- attr(quo, "dplyr:::data")
        if (!is.null(quo_data$column)) {
          context_poke("column", quo_data$column)
        }
        # a list in which each element is the result of
        # evaluating the quosure in the "sliced data mask"
        # recycling it appropriately to match the group size
        #
        # TODO: reinject hybrid evaluation at the R level
        chunks <- NULL
        
        # result after unchopping the chunks
        result <- NULL
        
        if (quo_is_symbol(quo)){
          name <- as_string(quo_get_expr(quo))
          
          if (name %in% names(new_columns)) {
            # already have result and chunks
            result <- new_columns[[name]]
            chunks <- mask$resolve(name)
          } else if (name %in% names(.data)) {
            # column from the original data
            result <- .data[[name]]
            chunks <- mask$resolve(name)
          }
          
          if (inherits(.data, "rowwise_df") && vec_is_list(result)) {
            sizes <- list_sizes(result)
            wrong <- which(sizes != 1)
            if (length(wrong)) {
              # same error as would have been generated by mask$eval_all_mutate()
              group <- wrong[1L]
              mask$set_current_group(group)
              
              abort(
                class = c("dplyr:::mutate_incompatible_size", "dplyr:::internal_error"),
                dplyr_error_data = list(result_size = sizes[group], expected_size = 1)
              )
            }
          }
        } else if (!quo_is_symbolic(quo) && !is.null(quo_get_expr(quo))) {
          # constant, we still need both `result` and `chunks`
          result <- quo_get_expr(quo)
          
          result <- withCallingHandlers(
            vec_recycle(result, vec_size(.data)),
            error = function(cnd) {
              abort(
                class = c("dplyr:::mutate_constant_recycle_error", "dplyr:::internal_error"),
                constant_size = vec_size(result), data_size = vec_size(.data)
              )
            }
          )
          
          chunks <- vec_chop(result, rows)
        }
        
        if (is.null(chunks)) {
          if (is.null(quo_data$column)) {
            chunks <- mask$eval_all_mutate(quo)
          } else {
            chunks <- withCallingHandlers(
              mask$eval_all_mutate(quo),
              error = function(cnd) {
                msg <- glue("Problem while computing column `{quo_data$name_auto}`.")
                abort(msg, call = call("across"), parent = cnd)
              }
            )
          }
        }
        
        if (is.null(chunks)) {
          next
        }
        
        # only unchop if needed
        if (is.null(result)) {
          if (length(rows) == 1) {
            result <- chunks[[1]]
          } else {
            chunks <- dplyr_vec_cast_common(chunks, quo_data$name_auto)
            result <- vec_unchop(chunks, rows)
          }
        }
        
        quosures_results[[k]] <- list(result = result, chunks = chunks)
      }
      
      
      for (k in seq_along(quosures)) {
        quo <- quosures[[k]]
        quo_data <- attr(quo, "dplyr:::data")
        
        quo_result <- quosures_results[[k]]
        if (is.null(quo_result)) {
          if (quo_data$is_named) {
            name <- quo_data$name_given
            new_columns[[name]] <- zap()
            mask$remove(name)
          }
          next
        }
        
        result <- quo_result$result
        chunks <- quo_result$chunks
        
        if (!quo_data$is_named && is.data.frame(result)) {
          types <- vec_ptype(result)
          types_names <- names(types)
          chunks_extracted <- .Call(dplyr_extract_chunks, chunks, types)
          
          for (j in seq_along(types)) {
            mask$add_one(types_names[j], chunks_extracted[[j]], result = result[[j]])
          }
          
          new_columns[types_names] <- result
        } else {
          # treat as a single output otherwise
          name <- quo_data$name_auto
          mask$add_one(name = name, chunks = chunks, result = result)
          
          new_columns[[name]] <- result
        }
        
      }
      
    }
    
  },
  error = function(e) {
    local_error_context(dots = dots, .index = i, mask = mask)
    
    bullets <- c(
      cnd_bullet_header("computing"),
      mutate_bullets(e)
    )
    
    abort(
      bullets,
      class = "dplyr:::mutate_error",
      parent = skip_internal_condition(e),
      bullets = bullets,
      call = error_call
    )
  },
  warning = function(w) {
    # Check if there is an upstack calling handler that would muffle
    # the warning. This avoids doing the expensive work below for a
    # silenced warning (#5675).
    if (check_muffled_warning(w)) {
      maybe_restart("muffleWarning")
    }
    
    local_error_context(dots = dots, .index = i, mask = mask)
    
    warn(c(
      cnd_bullet_header("computing"),
      i = cnd_header(w),
      i = cnd_bullet_cur_group_label(what = "warning")
    ))
    
    # Cancel `w`
    maybe_restart("muffleWarning")
  })
  
  is_zap <- map_lgl(new_columns, inherits, "rlang_zap")
  new_columns[is_zap] <- rep(list(NULL), sum(is_zap))
  used <- mask$get_used()
  names(used) <- mask$current_vars()
  attr(new_columns, "used") <- used
  new_columns
}